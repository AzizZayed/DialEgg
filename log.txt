Supported ops: arith.addf, arith.addi, arith.andi, arith.cmpf, arith.constant, arith.divf, arith.maximumf, arith.minimumf, arith.mulf, arith.negf, arith_addf, arith_addi, arith_andi, arith_cmpf, arith_constant, arith_divf, arith_maximumf, arith_minimumf, arith_mulf, arith_negf, linalg.matmul, linalg.transpose, linalg_matmul, linalg_transpose, math.cos, math.powf, math.sin, math_cos, math_powf, math_sin, 
Supported dialects: arith, linalg, math, 

Supported ops: arith.addf, arith.addi, arith.andi, arith.cmpf, arith.constant, arith.divf, arith.maximumf, arith.minimumf, arith.mulf, arith.negf, arith_addf, arith_addi, arith_andi, arith_cmpf, arith_constant, arith_divf, arith_maximumf, arith_minimumf, arith_mulf, arith_negf, linalg.matmul, linalg.transpose, linalg_matmul, linalg_transpose, math.cos, math.powf, math.sin, math_cos, math_powf, math_sin, 
Supported dialects: arith, linalg, math, 

EqSatOp op0 = arith.constant ( value = 0 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":11:11))
EqSatOp op1 = arith.constant ( value = 1 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":12:11))
EqSatOp op2 = arith.constant ( value = 91 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":14:17))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op3 = func.call ( callee = @putchar ) [ op2 ] : i32 (loc("mlir/linalg_assoc.mlir":15:5))
Unsupported operation 'tensor.dim' but using the result as a variable.
EqSatOp op4 = %arg0 ( ) [ ] : tensor<?xi64>
EqSatOp op5 = tensor.dim ( ) [ op4 op0 ] : index (loc("mlir/linalg_assoc.mlir":17:13))
Ignoring unsupported operation 'scf.for'
EqSatOp op6 = arith.constant ( value = 93 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":29:17))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op7 = func.call ( callee = @putchar ) [ op6 ] : i32 (loc("mlir/linalg_assoc.mlir":30:5))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Declared function op7.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.001s, apply 0.000s, rebuild 0.000s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 8: (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
[INFO ] extracted with cost 8: (arith_constant 6 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))
(arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
(arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
(arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
(arith_constant 6 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))


Done running egglog

ID 0
OP: %c0 = arith.constant 0 : index
VALUE %c0 = %c0 = arith.constant 0 : index

ID 1
OP: %c1 = arith.constant 1 : index
VALUE %c1 = %c1 = arith.constant 1 : index

ID 2
OP: %c91_i32 = arith.constant 91 : i32
VALUE %c91_i32 = %c91_i32 = arith.constant 91 : i32

ID 3
OP: %0 = func.call @putchar(%c91_i32) : (i32) -> i32
VALUE %0 = %0 = func.call @putchar(%c91_i32) : (i32) -> i32

ID 4
VALUE %arg0 = <block argument> of type 'tensor<?xi64>' at index: 0

ID 5
OP: %dim = tensor.dim %arg0, %c0 : tensor<?xi64>
VALUE %dim = %dim = tensor.dim %arg0, %c0 : tensor<?xi64>

ID 6
OP: %c93_i32 = arith.constant 93 : i32
VALUE %c93_i32 = %c93_i32 = arith.constant 93 : i32

ID 7
OP: %1 = func.call @putchar(%c93_i32) : (i32) -> i32
VALUE %1 = %1 = func.call @putchar(%c93_i32) : (i32) -> i32

op0 = (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
NEW OPERATION 0 : %c0 = arith.constant 0 : index
OLD OPERATION 0 : %c0 = arith.constant 0 : index

op1 = (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
NEW OPERATION 1 : %c1 = arith.constant 1 : index
OLD OPERATION 1 : %c1 = arith.constant 1 : index

op2 = (arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
NEW OPERATION 2 : %c91_i32 = arith.constant 91 : i32
OLD OPERATION 2 : %c91_i32 = arith.constant 91 : i32

op6 = (arith_constant 6 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))
NEW OPERATION 6 : %c93_i32 = arith.constant 93 : i32
OLD OPERATION 6 : %c93_i32 = arith.constant 93 : i32


EqSatOp op0 = arith.constant ( value = 0 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":36:11))
EqSatOp op1 = arith.constant ( value = 1 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":37:11))
EqSatOp op2 = arith.constant ( value = 91 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":39:17))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op3 = func.call ( callee = @putchar ) [ op2 ] : i32 (loc("mlir/linalg_assoc.mlir":40:5))
EqSatOp op4 = arith.constant ( value = 9 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":42:12))
Unsupported operation 'tensor.dim' but using the result as a variable.
EqSatOp op5 = %arg0 ( ) [ ] : tensor<?x?xi64>
EqSatOp op6 = tensor.dim ( ) [ op5 op0 ] : index (loc("mlir/linalg_assoc.mlir":44:14))
Unsupported operation 'tensor.dim' but using the result as a variable.
EqSatOp op7 = tensor.dim ( ) [ op5 op1 ] : index (loc("mlir/linalg_assoc.mlir":45:14))
Ignoring unsupported operation 'scf.for'
Unsupported operation 'index.cmp' but using the result as a variable.
EqSatOp op8 = index.cmp ( pred = #index<cmp_predicate sgt> ) [ op6 op0 ] : i1 (loc("mlir/linalg_assoc.mlir":61:19))
Ignoring unsupported operation 'scf.if'
EqSatOp op9 = arith.constant ( value = 93 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":66:17))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op10 = func.call ( callee = @putchar ) [ op9 ] : i32 (loc("mlir/linalg_assoc.mlir":67:5))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Declared function op7.
[INFO ] Declared function op8.
[INFO ] Declared function op9.
[INFO ] Declared function op10.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 1
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 1
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.001s, apply 0.000s, rebuild 0.000s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 8: (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
[INFO ] extracted with cost 8: (arith_constant 4 (NamedAttr "value" (IntegerAttr 9 (I32))) (I32))
[INFO ] extracted with cost 8: (arith_constant 9 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))
(arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
(arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
(arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
(arith_constant 4 (NamedAttr "value" (IntegerAttr 9 (I32))) (I32))
(arith_constant 9 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))


Done running egglog

ID 0
OP: %c0 = arith.constant 0 : index
VALUE %c0 = %c0 = arith.constant 0 : index

ID 1
OP: %c1 = arith.constant 1 : index
VALUE %c1 = %c1 = arith.constant 1 : index

ID 2
OP: %c91_i32 = arith.constant 91 : i32
VALUE %c91_i32 = %c91_i32 = arith.constant 91 : i32

ID 3
OP: %0 = func.call @putchar(%c91_i32) : (i32) -> i32
VALUE %0 = %0 = func.call @putchar(%c91_i32) : (i32) -> i32

ID 4
OP: %c9_i32 = arith.constant 9 : i32
VALUE %c9_i32 = %c9_i32 = arith.constant 9 : i32

ID 5
VALUE %arg0 = <block argument> of type 'tensor<?x?xi64>' at index: 0

ID 6
OP: %dim = tensor.dim %arg0, %c0 : tensor<?x?xi64>
VALUE %dim = %dim = tensor.dim %arg0, %c0 : tensor<?x?xi64>

ID 7
OP: %dim_0 = tensor.dim %arg0, %c1 : tensor<?x?xi64>
VALUE %dim_0 = %dim_0 = tensor.dim %arg0, %c1 : tensor<?x?xi64>

ID 8
OP: %1 = index.cmp sgt(%dim, %c0)
VALUE %1 = %1 = index.cmp sgt(%dim, %c0)

ID 9
OP: %c93_i32 = arith.constant 93 : i32
VALUE %c93_i32 = %c93_i32 = arith.constant 93 : i32

ID 10
OP: %2 = func.call @putchar(%c93_i32) : (i32) -> i32
VALUE %2 = %2 = func.call @putchar(%c93_i32) : (i32) -> i32

op0 = (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
NEW OPERATION 0 : %c0 = arith.constant 0 : index
OLD OPERATION 0 : %c0 = arith.constant 0 : index

op1 = (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
NEW OPERATION 1 : %c1 = arith.constant 1 : index
OLD OPERATION 1 : %c1 = arith.constant 1 : index

op2 = (arith_constant 2 (NamedAttr "value" (IntegerAttr 91 (I32))) (I32))
NEW OPERATION 2 : %c91_i32 = arith.constant 91 : i32
OLD OPERATION 2 : %c91_i32 = arith.constant 91 : i32

op4 = (arith_constant 4 (NamedAttr "value" (IntegerAttr 9 (I32))) (I32))
NEW OPERATION 4 : %c9_i32 = arith.constant 9 : i32
OLD OPERATION 4 : %c9_i32 = arith.constant 9 : i32

op9 = (arith_constant 9 (NamedAttr "value" (IntegerAttr 93 (I32))) (I32))
NEW OPERATION 9 : %c93_i32 = arith.constant 93 : i32
OLD OPERATION 9 : %c93_i32 = arith.constant 93 : i32


EqSatOp op0 = arith.constant ( value = 0 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":75:11))
EqSatOp op1 = arith.constant ( value = 1 : index ) [ ] : index (loc("mlir/linalg_assoc.mlir":76:11))
Unsupported operation 'tensor.dim' but using the result as a variable.
EqSatOp op2 = %arg0 ( ) [ ] : tensor<?x?xi64>
EqSatOp op3 = tensor.dim ( ) [ op2 op1 ] : index (loc("mlir/linalg_assoc.mlir":78:13))
Unsupported operation 'tensor.dim' but using the result as a variable.
EqSatOp op4 = tensor.dim ( ) [ op2 op0 ] : index (loc("mlir/linalg_assoc.mlir":79:13))
EqSatOp op5 = arith.constant ( value = 0 : i32 ) [ ] : i32 (loc("mlir/linalg_assoc.mlir":81:13))
EqSatOp op6 = arith.constant ( value = 0.000000e+00 : f64 ) [ ] : f64 (loc("mlir/linalg_assoc.mlir":82:12))
EqSatOp op7 = arith.constant ( value = 1.000000e+01 : f64 ) [ ] : f64 (loc("mlir/linalg_assoc.mlir":83:12))
Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op8 = tensor.empty ( ) [ op4 op3 ] : tensor<?x?xf64> (loc("mlir/linalg_assoc.mlir":84:13))
Unsupported operation 'linalg.fill_rng_2d' but using the result as a variable.
EqSatOp op9 = linalg.fill_rng_2d ( linalg.memoized_indexing_maps = [affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> ()>, affine_map<(d0, d1) -> (d0, d1)>] operandSegmentSizes = array<i32: 3, 1> ) [ op6 op7 op5 op8 ] : tensor<?x?xf64> (loc("mlir/linalg_assoc.mlir":86:20))
Unsupported operation 'linalg.floor' but using the result as a variable.
EqSatOp op10 = linalg.floor ( operandSegmentSizes = array<i32: 1, 1> ) [ op9 op8 ] : tensor<?x?xf64> (loc("mlir/linalg_assoc.mlir":90:19))
Unsupported operation 'linalg.generic' but using the result as a variable.
EqSatOp op11 = linalg.generic ( indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>] iterator_types = [#linalg.iterator_type<parallel>, #linalg.iterator_type<parallel>] operandSegmentSizes = array<i32: 1, 1> ) [ op10 op2 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":91:22))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Declared function op7.
[INFO ] Declared function op8.
[INFO ] Declared function op9.
[INFO ] Declared function op10.
[INFO ] Declared function op11.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.001s, apply 0.000s, rebuild 0.000s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 8: (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
[INFO ] extracted with cost 8: (arith_constant 5 (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))
[INFO ] extracted with cost 8: (arith_constant 6 (NamedAttr "value" (FloatAttr 0.0 (F64))) (F64))
[INFO ] extracted with cost 8: (arith_constant 7 (NamedAttr "value" (FloatAttr 10.0 (F64))) (F64))
(arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
(arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
(arith_constant 5 (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))
(arith_constant 6 (NamedAttr "value" (FloatAttr 0.0 (F64))) (F64))
(arith_constant 7 (NamedAttr "value" (FloatAttr 10.0 (F64))) (F64))


Done running egglog

ID 0
OP: %c0 = arith.constant 0 : index
VALUE %c0 = %c0 = arith.constant 0 : index

ID 1
OP: %c1 = arith.constant 1 : index
VALUE %c1 = %c1 = arith.constant 1 : index

ID 2
VALUE %arg0 = <block argument> of type 'tensor<?x?xi64>' at index: 0

ID 3
OP: %dim = tensor.dim %arg0, %c1 : tensor<?x?xi64>
VALUE %dim = %dim = tensor.dim %arg0, %c1 : tensor<?x?xi64>

ID 4
OP: %dim_0 = tensor.dim %arg0, %c0 : tensor<?x?xi64>
VALUE %dim_0 = %dim_0 = tensor.dim %arg0, %c0 : tensor<?x?xi64>

ID 5
OP: %c0_i32 = arith.constant 0 : i32
VALUE %c0_i32 = %c0_i32 = arith.constant 0 : i32

ID 6
OP: %cst = arith.constant 0.000000e+00 : f64
VALUE %cst = %cst = arith.constant 0.000000e+00 : f64

ID 7
OP: %cst_1 = arith.constant 1.000000e+01 : f64
VALUE %cst_1 = %cst_1 = arith.constant 1.000000e+01 : f64

ID 8
OP: %0 = tensor.empty(%dim_0, %dim) : tensor<?x?xf64>
VALUE %0 = %0 = tensor.empty(%dim_0, %dim) : tensor<?x?xf64>

ID 9
OP: %1 = linalg.fill_rng_2d ins(%cst, %cst_1, %c0_i32 : f64, f64, i32) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>
VALUE %1 = %1 = linalg.fill_rng_2d ins(%cst, %cst_1, %c0_i32 : f64, f64, i32) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>

ID 10
OP: %2 = linalg.floor ins(%1 : tensor<?x?xf64>) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>
VALUE %2 = %2 = linalg.floor ins(%1 : tensor<?x?xf64>) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>

ID 11
OP: %3 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%2 : tensor<?x?xf64>) outs(%arg0 : tensor<?x?xi64>) {
^bb0(%in: f64, %out: i64):
  %4 = arith.fptosi %in : f64 to i64
  linalg.yield %4 : i64
} -> tensor<?x?xi64>
VALUE %3 = %3 = linalg.generic {indexing_maps = [affine_map<(d0, d1) -> (d0, d1)>, affine_map<(d0, d1) -> (d0, d1)>], iterator_types = ["parallel", "parallel"]} ins(%2 : tensor<?x?xf64>) outs(%arg0 : tensor<?x?xi64>) {
^bb0(%in: f64, %out: i64):
  %4 = arith.fptosi %in : f64 to i64
  linalg.yield %4 : i64
} -> tensor<?x?xi64>

op0 = (arith_constant 0 (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))
NEW OPERATION 0 : %c0 = arith.constant 0 : index
OLD OPERATION 0 : %c0 = arith.constant 0 : index

op1 = (arith_constant 1 (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))
NEW OPERATION 1 : %c1 = arith.constant 1 : index
OLD OPERATION 1 : %c1 = arith.constant 1 : index

op5 = (arith_constant 5 (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))
NEW OPERATION 5 : %c0_i32 = arith.constant 0 : i32
OLD OPERATION 5 : %c0_i32 = arith.constant 0 : i32

op6 = (arith_constant 6 (NamedAttr "value" (FloatAttr 0.0 (F64))) (F64))
NEW OPERATION 6 : %cst = arith.constant 0.000000e+00 : f64
OLD OPERATION 6 : %cst = arith.constant 0.000000e+00 : f64

op7 = (arith_constant 7 (NamedAttr "value" (FloatAttr 10.0 (F64))) (F64))
NEW OPERATION 7 : %cst_1 = arith.constant 1.000000e+01 : f64
OLD OPERATION 7 : %cst_1 = arith.constant 1.000000e+01 : f64


Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op0 = tensor.empty ( ) [ ] : tensor<10000x15000xi64> (loc("mlir/linalg_assoc.mlir":104:16))
EqSatOp op1 = %arg0 ( ) [ ] : tensor<10000x10xi64>
EqSatOp op2 = %arg1 ( ) [ ] : tensor<10x15000xi64>
EqSatOp op3 = linalg.matmul ( linalg.memoized_indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>] operandSegmentSizes = array<i32: 2, 1> ) [ op1 op2 op0 ] : tensor<10000x15000xi64> (loc("mlir/linalg_assoc.mlir":105:11))
Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op4 = tensor.empty ( ) [ ] : tensor<10000x8xi64> (loc("mlir/linalg_assoc.mlir":108:18))
EqSatOp op5 = %arg2 ( ) [ ] : tensor<15000x8xi64>
EqSatOp op6 = linalg.matmul ( linalg.memoized_indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>] operandSegmentSizes = array<i32: 2, 1> ) [ op3 op5 op4 ] : tensor<10000x8xi64> (loc("mlir/linalg_assoc.mlir":109:13))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.001s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.001s, apply 0.000s, num matches 2
    Ruleset : search 0.003s, apply 0.000s, rebuild 0.001s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 1500000042: (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64)))
[INFO ] extracted with cost 2700000078: (linalg_matmul 6 (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64))) (NamedOp 5 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))
(linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64)))
(linalg_matmul 6 (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64))) (NamedOp 5 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))


Done running egglog

ID 0
OP: %0 = tensor.empty() : tensor<10000x15000xi64>
VALUE %0 = %0 = tensor.empty() : tensor<10000x15000xi64>

ID 1
VALUE %arg0 = <block argument> of type 'tensor<10000x10xi64>' at index: 0

ID 2
VALUE %arg1 = <block argument> of type 'tensor<10x15000xi64>' at index: 1

ID 3
OP: %1 = linalg.matmul ins(%arg0, %arg1 : tensor<10000x10xi64>, tensor<10x15000xi64>) outs(%0 : tensor<10000x15000xi64>) -> tensor<10000x15000xi64>
VALUE %1 = %1 = linalg.matmul ins(%arg0, %arg1 : tensor<10000x10xi64>, tensor<10x15000xi64>) outs(%0 : tensor<10000x15000xi64>) -> tensor<10000x15000xi64>

ID 4
OP: %2 = tensor.empty() : tensor<10000x8xi64>
VALUE %2 = %2 = tensor.empty() : tensor<10000x8xi64>

ID 5
VALUE %arg2 = <block argument> of type 'tensor<15000x8xi64>' at index: 2

ID 6
OP: %3 = linalg.matmul ins(%1, %arg2 : tensor<10000x15000xi64>, tensor<15000x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
VALUE %3 = %3 = linalg.matmul ins(%1, %arg2 : tensor<10000x15000xi64>, tensor<15000x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>

op3 = (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64)))
NEW OPERATION 3 : %1 = linalg.matmul ins(%arg0, %arg1 : tensor<10000x10xi64>, tensor<10x15000xi64>) outs(%0 : tensor<10000x15000xi64>) -> tensor<10000x15000xi64>
OLD OPERATION 3 : %1 = linalg.matmul ins(%arg0, %arg1 : tensor<10000x10xi64>, tensor<10x15000xi64>) outs(%0 : tensor<10000x15000xi64>) -> tensor<10000x15000xi64>

op6 = (linalg_matmul 6 (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10000 10) (I64))) (NamedOp 2 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 0 (RankedTensor (vec-of 10000 15000) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 15000) (I64))) (NamedOp 5 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))
NEW OPERATION 6 : %3 = linalg.matmul ins(%1, %arg2 : tensor<10000x15000xi64>, tensor<15000x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
OLD OPERATION 6 : %3 = linalg.matmul ins(%1, %arg2 : tensor<10000x15000xi64>, tensor<15000x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>


Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op0 = tensor.empty ( ) [ ] : tensor<10x8xi64> (loc("mlir/linalg_assoc.mlir":116:16))
EqSatOp op1 = %arg1 ( ) [ ] : tensor<10x15000xi64>
EqSatOp op2 = %arg2 ( ) [ ] : tensor<15000x8xi64>
EqSatOp op3 = linalg.matmul ( linalg.memoized_indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>] operandSegmentSizes = array<i32: 2, 1> ) [ op1 op2 op0 ] : tensor<10x8xi64> (loc("mlir/linalg_assoc.mlir":117:11))
Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op4 = tensor.empty ( ) [ ] : tensor<10000x8xi64> (loc("mlir/linalg_assoc.mlir":120:18))
EqSatOp op5 = %arg0 ( ) [ ] : tensor<10000x10xi64>
EqSatOp op6 = linalg.matmul ( linalg.memoized_indexing_maps = [affine_map<(d0, d1, d2) -> (d0, d2)>, affine_map<(d0, d1, d2) -> (d2, d1)>, affine_map<(d0, d1, d2) -> (d0, d1)>] operandSegmentSizes = array<i32: 2, 1> ) [ op5 op3 op4 ] : tensor<10000x8xi64> (loc("mlir/linalg_assoc.mlir":121:13))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.001s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.001s, apply 0.000s, num matches 2
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 5
    Ruleset : search 0.002s, apply 0.000s, rebuild 0.001s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 1200042: (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64)))
[INFO ] extracted with cost 2000078: (linalg_matmul 6 (NamedOp 5 (RankedTensor (vec-of 10000 10) (I64))) (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))
(linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64)))
(linalg_matmul 6 (NamedOp 5 (RankedTensor (vec-of 10000 10) (I64))) (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))


Done running egglog

ID 0
OP: %0 = tensor.empty() : tensor<10x8xi64>
VALUE %0 = %0 = tensor.empty() : tensor<10x8xi64>

ID 1
VALUE %arg1 = <block argument> of type 'tensor<10x15000xi64>' at index: 1

ID 2
VALUE %arg2 = <block argument> of type 'tensor<15000x8xi64>' at index: 2

ID 3
OP: %1 = linalg.matmul ins(%arg1, %arg2 : tensor<10x15000xi64>, tensor<15000x8xi64>) outs(%0 : tensor<10x8xi64>) -> tensor<10x8xi64>
VALUE %1 = %1 = linalg.matmul ins(%arg1, %arg2 : tensor<10x15000xi64>, tensor<15000x8xi64>) outs(%0 : tensor<10x8xi64>) -> tensor<10x8xi64>

ID 4
OP: %2 = tensor.empty() : tensor<10000x8xi64>
VALUE %2 = %2 = tensor.empty() : tensor<10000x8xi64>

ID 5
VALUE %arg0 = <block argument> of type 'tensor<10000x10xi64>' at index: 0

ID 6
OP: %3 = linalg.matmul ins(%arg0, %1 : tensor<10000x10xi64>, tensor<10x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
VALUE %3 = %3 = linalg.matmul ins(%arg0, %1 : tensor<10000x10xi64>, tensor<10x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>

op3 = (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64)))
NEW OPERATION 3 : %1 = linalg.matmul ins(%arg1, %arg2 : tensor<10x15000xi64>, tensor<15000x8xi64>) outs(%0 : tensor<10x8xi64>) -> tensor<10x8xi64>
OLD OPERATION 3 : %1 = linalg.matmul ins(%arg1, %arg2 : tensor<10x15000xi64>, tensor<15000x8xi64>) outs(%0 : tensor<10x8xi64>) -> tensor<10x8xi64>

op6 = (linalg_matmul 6 (NamedOp 5 (RankedTensor (vec-of 10000 10) (I64))) (linalg_matmul 3 (NamedOp 1 (RankedTensor (vec-of 10 15000) (I64))) (NamedOp 2 (RankedTensor (vec-of 15000 8) (I64))) (NamedOp 0 (RankedTensor (vec-of 10 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10 8) (I64))) (NamedOp 4 (RankedTensor (vec-of 10000 8) (I64))) (NamedAttr "linalg.memoized_indexing_maps" (ArrayAttr (vec-of (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d2)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d2, d1)>" "builtin.affine_map") (OtherAttr "affine_map<(d0, d1, d2) -> (d0, d1)>" "builtin.affine_map")))) (NamedAttr "operandSegmentSizes" (DenseIntArrayAttr 2 (vec-of 4294967298 4924377760) (I32))) (RankedTensor (vec-of 10000 8) (I64)))
NEW OPERATION 6 : %3 = linalg.matmul ins(%arg0, %1 : tensor<10000x10xi64>, tensor<10x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
OLD OPERATION 6 : %3 = linalg.matmul ins(%arg0, %1 : tensor<10000x10xi64>, tensor<10x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>


Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op0 = tensor.empty ( ) [ ] : tensor<10000x10xi64> (loc("mlir/linalg_assoc.mlir":129:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op1 = tensor.cast ( ) [ op0 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":130:15))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op2 = func.call ( callee = @fillRandomI64Tensor2D ) [ op1 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":131:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op3 = tensor.cast ( ) [ op2 ] : tensor<10000x10xi64> (loc("mlir/linalg_assoc.mlir":133:10))
Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op4 = tensor.empty ( ) [ ] : tensor<10x15000xi64> (loc("mlir/linalg_assoc.mlir":135:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op5 = tensor.cast ( ) [ op4 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":136:15))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op6 = func.call ( callee = @fillRandomI64Tensor2D ) [ op5 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":137:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op7 = tensor.cast ( ) [ op6 ] : tensor<10x15000xi64> (loc("mlir/linalg_assoc.mlir":139:10))
Unsupported operation 'tensor.empty' but using the result as a variable.
EqSatOp op8 = tensor.empty ( ) [ ] : tensor<15000x8xi64> (loc("mlir/linalg_assoc.mlir":141:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op9 = tensor.cast ( ) [ op8 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":142:15))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op10 = func.call ( callee = @fillRandomI64Tensor2D ) [ op9 ] : tensor<?x?xi64> (loc("mlir/linalg_assoc.mlir":143:15))
Unsupported operation 'tensor.cast' but using the result as a variable.
EqSatOp op11 = tensor.cast ( ) [ op10 ] : tensor<15000x8xi64> (loc("mlir/linalg_assoc.mlir":145:10))
Unsupported operation 'func.call' but using the result as a variable.
EqSatOp op12 = func.call ( callee = @xy_z ) [ op3 op7 op11 ] : tensor<10000x8xi64> (loc("mlir/linalg_assoc.mlir":147:5))
EqSatOp op13 = arith.constant ( value = 0.000000e+00 : f32 ) [ ] : f32 (loc("mlir/linalg_assoc.mlir":150:12))
Ignoring unsupported operation 'func.return'

Running egglog: ~/dev/lib/egglog/target/debug/egglog egg/rules.egg --to-svg > egg/egglog-extract.txt 2> egg/egglog-log.txt

[INFO ] Declared sort IntVec.
[INFO ] Declared sort FloatVec.
[INFO ] Declared sort Type.
[INFO ] Declared sort TypeVec.
[INFO ] Declared function F16.
[INFO ] Declared function F32.
[INFO ] Declared function F64.
[INFO ] Declared function F80.
[INFO ] Declared function F128.
[INFO ] Declared function I1.
[INFO ] Declared function I4.
[INFO ] Declared function I8.
[INFO ] Declared function I16.
[INFO ] Declared function I32.
[INFO ] Declared function I64.
[INFO ] Declared function Int.
[INFO ] Declared function SInt.
[INFO ] Declared function UInt.
[INFO ] Declared function OtherInt.
[INFO ] Declared function Index.
[INFO ] Declared function None.
[INFO ] Declared function Complex.
[INFO ] Declared function Tuple.
[INFO ] Declared function RankedTensor.
[INFO ] Declared function UnrankedTensor.
[INFO ] Declared function OtherType.
[INFO ] Declared sort Attr.
[INFO ] Declared sort AttrDict.
[INFO ] Declared sort AttrVec.
[INFO ] Declared sort AttrPair.
[INFO ] Declared function NamedAttr.
[INFO ] Declared sort AttrPairVec.
[INFO ] Declared function NoAttr.
[INFO ] Declared function IntegerAttr.
[INFO ] Declared function FloatAttr.
[INFO ] Declared function StringAttr.
[INFO ] Declared function UnitAttr.
[INFO ] Declared function TypeAttr.
[INFO ] Declared function ArrayAttr.
[INFO ] Declared function DenseIntArrayAttr.
[INFO ] Declared function DenseFloatArrayAttr.
[INFO ] Declared function DenseIntElementsAttr.
[INFO ] Declared function DenseFPElementsAttr.
[INFO ] Declared function OtherAttr.
[INFO ] Declared sort Op.
[INFO ] Declared function NamedOp.
[INFO ] Declared sort FastMathFlags.
[INFO ] Declared function none.
[INFO ] Declared function reassoc.
[INFO ] Declared function nnan.
[INFO ] Declared function arith_fastmath.
[INFO ] Declared function arith_constant.
[INFO ] Declared function arith_addf.
[INFO ] Declared function arith_addi.
[INFO ] Declared function arith_divf.
[INFO ] Declared function arith_mulf.
[INFO ] Declared function arith_negf.
[INFO ] Declared function arith_maximumf.
[INFO ] Declared function arith_minimumf.
[INFO ] Declared function arith_andi.
[INFO ] Declared function arith_cmpf.
[INFO ] Declared function linalg_transpose.
[INFO ] Declared function linalg_matmul.
[INFO ] Declared rule (rewrite (arith_addf ?i0 (arith_constant ?i1 (NamedAttr 'value' (FloatAttr ?x ?t)) ?t) (arith_constant ?i2 (NamedAttr 'value' (FloatAttr ?y ?t)) ?t) ?a ?t) (arith_constant -1 (NamedAttr 'value' (FloatAttr (+ ?x ?y) ?t)) ?t)).
[INFO ] Declared rule (rewrite (arith_addf ? ?x ?y ?a ?t) (arith_addf -1 ?y ?x ?a ?t)).
[INFO ] Declared rule (rewrite (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm ?t1) ?z ?perm ?t2) ?x).
[INFO ] Declared function nrows.
[INFO ] Declared function ncols.
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))
           (> (vec-length ?dims) 1))
          ((set (nrows ?m) (vec-get ?dims 0))
           (set (ncols ?m) (vec-get ?dims 1)))
             ).
[INFO ] Declared rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))
           (= ?a (nrows ?x))
           (= ?b (ncols ?x))
           (= ?c (ncols ?y)))
          ((set (nrows ?m) ?a)
           (set (ncols ?m) ?c)
           (unstable-cost (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)) (* (* ?a ?b) ?c)))
             ).
[INFO ] Declared function op0.
[INFO ] Declared function op1.
[INFO ] Declared function op2.
[INFO ] Declared function op3.
[INFO ] Declared function op4.
[INFO ] Declared function op5.
[INFO ] Declared function op6.
[INFO ] Declared function op7.
[INFO ] Declared function op8.
[INFO ] Declared function op9.
[INFO ] Declared function op10.
[INFO ] Declared function op11.
[INFO ] Declared function op12.
[INFO ] Declared function op13.
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 13
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 13
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.001s, apply 0.000s, rebuild 0.000s
    
[INFO ] Ran schedule (repeat 10000 (run)).
[INFO ] Report: Rule (rule ((= rewrite_var__ (linalg_transpose ?id (linalg_transpose ?id2 ?x ?y ?perm...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (arith_constant ?id ?attr (RankedTensor ?dims ?t)))        (> (vec-...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (linalg_matmul ?id ?x ?y ?o ?attr1 ?attr2 (RankedTensor ?d ?t)))   ...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ?i0 (arith_constant ?i1 (NamedAttr "value" (...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= ?m (NamedOp ?id (RankedTensor ?dims ?t)))        (> (vec-length ?dims)...: search 0.000s, apply 0.000s, num matches 0
    Rule (rule ((= rewrite_var__ (arith_addf ? ?x ?y ?a ?t)))       ((union rewrite_var__...: search 0.000s, apply 0.000s, num matches 0
    Ruleset : search 0.000s, apply 0.000s, rebuild 0.000s
    
[INFO ] extracted with cost 8: (arith_constant 13 (NamedAttr "value" (FloatAttr 0.0 (F32))) (F32))
(arith_constant 13 (NamedAttr "value" (FloatAttr 0.0 (F32))) (F32))


Done running egglog

ID 0
OP: %0 = tensor.empty() : tensor<10000x10xi64>
VALUE %0 = %0 = tensor.empty() : tensor<10000x10xi64>

ID 1
OP: %cast = tensor.cast %0 : tensor<10000x10xi64> to tensor<?x?xi64>
VALUE %cast = %cast = tensor.cast %0 : tensor<10000x10xi64> to tensor<?x?xi64>

ID 2
OP: %1 = func.call @fillRandomI64Tensor2D(%cast) : (tensor<?x?xi64>) -> tensor<?x?xi64>
VALUE %1 = %1 = func.call @fillRandomI64Tensor2D(%cast) : (tensor<?x?xi64>) -> tensor<?x?xi64>

ID 3
OP: %cast_0 = tensor.cast %1 : tensor<?x?xi64> to tensor<10000x10xi64>
VALUE %cast_0 = %cast_0 = tensor.cast %1 : tensor<?x?xi64> to tensor<10000x10xi64>

ID 4
OP: %2 = tensor.empty() : tensor<10x15000xi64>
VALUE %2 = %2 = tensor.empty() : tensor<10x15000xi64>

ID 5
OP: %cast_1 = tensor.cast %2 : tensor<10x15000xi64> to tensor<?x?xi64>
VALUE %cast_1 = %cast_1 = tensor.cast %2 : tensor<10x15000xi64> to tensor<?x?xi64>

ID 6
OP: %3 = func.call @fillRandomI64Tensor2D(%cast_1) : (tensor<?x?xi64>) -> tensor<?x?xi64>
VALUE %3 = %3 = func.call @fillRandomI64Tensor2D(%cast_1) : (tensor<?x?xi64>) -> tensor<?x?xi64>

ID 7
OP: %cast_2 = tensor.cast %3 : tensor<?x?xi64> to tensor<10x15000xi64>
VALUE %cast_2 = %cast_2 = tensor.cast %3 : tensor<?x?xi64> to tensor<10x15000xi64>

ID 8
OP: %4 = tensor.empty() : tensor<15000x8xi64>
VALUE %4 = %4 = tensor.empty() : tensor<15000x8xi64>

ID 9
OP: %cast_3 = tensor.cast %4 : tensor<15000x8xi64> to tensor<?x?xi64>
VALUE %cast_3 = %cast_3 = tensor.cast %4 : tensor<15000x8xi64> to tensor<?x?xi64>

ID 10
OP: %5 = func.call @fillRandomI64Tensor2D(%cast_3) : (tensor<?x?xi64>) -> tensor<?x?xi64>
VALUE %5 = %5 = func.call @fillRandomI64Tensor2D(%cast_3) : (tensor<?x?xi64>) -> tensor<?x?xi64>

ID 11
OP: %cast_4 = tensor.cast %5 : tensor<?x?xi64> to tensor<15000x8xi64>
VALUE %cast_4 = %cast_4 = tensor.cast %5 : tensor<?x?xi64> to tensor<15000x8xi64>

ID 12
OP: %6 = func.call @xy_z(%cast_0, %cast_2, %cast_4) : (tensor<10000x10xi64>, tensor<10x15000xi64>, tensor<15000x8xi64>) -> tensor<10000x8xi64>
VALUE %6 = %6 = func.call @xy_z(%cast_0, %cast_2, %cast_4) : (tensor<10000x10xi64>, tensor<10x15000xi64>, tensor<15000x8xi64>) -> tensor<10000x8xi64>

ID 13
OP: %cst = arith.constant 0.000000e+00 : f32
VALUE %cst = %cst = arith.constant 0.000000e+00 : f32

op13 = (arith_constant 13 (NamedAttr "value" (FloatAttr 0.0 (F32))) (F32))
NEW OPERATION 13 : %cst = arith.constant 0.000000e+00 : f32
OLD OPERATION 13 : %cst = arith.constant 0.000000e+00 : f32


#map = affine_map<(d0, d1) -> (d0, d1)>
module {
  func.func private @printI64(i64)
  func.func private @printF64(f64)
  func.func private @printComma()
  func.func private @printNewline()
  func.func private @putchar(i32) -> i32
  llvm.func @printf(!llvm.ptr, ...) -> i32
  func.func @printI64Tensor1D(%arg0: tensor<?xi64>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c91_i32 = arith.constant 91 : i32
    %0 = call @putchar(%c91_i32) : (i32) -> i32
    %dim = tensor.dim %arg0, %c0 : tensor<?xi64>
    scf.for %arg1 = %c0 to %dim step %c1 {
      %extracted = tensor.extract %arg0[%arg1] : tensor<?xi64>
      func.call @printI64(%extracted) : (i64) -> ()
      %2 = index.sub %dim, %c1
      %3 = index.cmp ult(%arg1, %2)
      scf.if %3 {
        func.call @printComma() : () -> ()
      }
    }
    %c93_i32 = arith.constant 93 : i32
    %1 = call @putchar(%c93_i32) : (i32) -> i32
    return
  }
  func.func @printI64Tensor2D(%arg0: tensor<?x?xi64>) {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %c91_i32 = arith.constant 91 : i32
    %0 = call @putchar(%c91_i32) : (i32) -> i32
    %c9_i32 = arith.constant 9 : i32
    %dim = tensor.dim %arg0, %c0 : tensor<?x?xi64>
    %dim_0 = tensor.dim %arg0, %c1 : tensor<?x?xi64>
    scf.for %arg1 = %c0 to %dim step %c1 {
      %extracted_slice = tensor.extract_slice %arg0[%arg1, 0] [1, %dim_0] [1, 1] : tensor<?x?xi64> to tensor<?xi64>
      func.call @printNewline() : () -> ()
      %3 = func.call @putchar(%c9_i32) : (i32) -> i32
      func.call @printI64Tensor1D(%extracted_slice) : (tensor<?xi64>) -> ()
      %4 = index.sub %dim, %c1
      %5 = index.cmp ult(%arg1, %4)
      scf.if %5 {
        func.call @printComma() : () -> ()
      }
    }
    %1 = index.cmp sgt(%dim, %c0)
    scf.if %1 {
      func.call @printNewline() : () -> ()
    }
    %c93_i32 = arith.constant 93 : i32
    %2 = call @putchar(%c93_i32) : (i32) -> i32
    return
  }
  func.func @fillRandomI64Tensor2D(%arg0: tensor<?x?xi64>) -> tensor<?x?xi64> {
    %c0 = arith.constant 0 : index
    %c1 = arith.constant 1 : index
    %dim = tensor.dim %arg0, %c1 : tensor<?x?xi64>
    %dim_0 = tensor.dim %arg0, %c0 : tensor<?x?xi64>
    %c0_i32 = arith.constant 0 : i32
    %cst = arith.constant 0.000000e+00 : f64
    %cst_1 = arith.constant 1.000000e+01 : f64
    %0 = tensor.empty(%dim_0, %dim) : tensor<?x?xf64>
    %1 = linalg.fill_rng_2d ins(%cst, %cst_1, %c0_i32 : f64, f64, i32) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>
    %2 = linalg.floor ins(%1 : tensor<?x?xf64>) outs(%0 : tensor<?x?xf64>) -> tensor<?x?xf64>
    %3 = linalg.generic {indexing_maps = [#map, #map], iterator_types = ["parallel", "parallel"]} ins(%2 : tensor<?x?xf64>) outs(%arg0 : tensor<?x?xi64>) {
    ^bb0(%in: f64, %out: i64):
      %4 = arith.fptosi %in : f64 to i64
      linalg.yield %4 : i64
    } -> tensor<?x?xi64>
    return %3 : tensor<?x?xi64>
  }
  func.func @xy_z(%arg0: tensor<10000x10xi64>, %arg1: tensor<10x15000xi64>, %arg2: tensor<15000x8xi64>) -> tensor<10000x8xi64> {
    %0 = tensor.empty() : tensor<10000x15000xi64>
    %1 = linalg.matmul ins(%arg0, %arg1 : tensor<10000x10xi64>, tensor<10x15000xi64>) outs(%0 : tensor<10000x15000xi64>) -> tensor<10000x15000xi64>
    %2 = tensor.empty() : tensor<10000x8xi64>
    %3 = linalg.matmul ins(%1, %arg2 : tensor<10000x15000xi64>, tensor<15000x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
    return %3 : tensor<10000x8xi64>
  }
  func.func @x_yz(%arg0: tensor<10000x10xi64>, %arg1: tensor<10x15000xi64>, %arg2: tensor<15000x8xi64>) -> tensor<10000x8xi64> {
    %0 = tensor.empty() : tensor<10x8xi64>
    %1 = linalg.matmul ins(%arg1, %arg2 : tensor<10x15000xi64>, tensor<15000x8xi64>) outs(%0 : tensor<10x8xi64>) -> tensor<10x8xi64>
    %2 = tensor.empty() : tensor<10000x8xi64>
    %3 = linalg.matmul ins(%arg0, %1 : tensor<10000x10xi64>, tensor<10x8xi64>) outs(%2 : tensor<10000x8xi64>) -> tensor<10000x8xi64>
    return %3 : tensor<10000x8xi64>
  }
  func.func @main() -> f32 {
    %0 = tensor.empty() : tensor<10000x10xi64>
    %cast = tensor.cast %0 : tensor<10000x10xi64> to tensor<?x?xi64>
    %1 = call @fillRandomI64Tensor2D(%cast) : (tensor<?x?xi64>) -> tensor<?x?xi64>
    %cast_0 = tensor.cast %1 : tensor<?x?xi64> to tensor<10000x10xi64>
    %2 = tensor.empty() : tensor<10x15000xi64>
    %cast_1 = tensor.cast %2 : tensor<10x15000xi64> to tensor<?x?xi64>
    %3 = call @fillRandomI64Tensor2D(%cast_1) : (tensor<?x?xi64>) -> tensor<?x?xi64>
    %cast_2 = tensor.cast %3 : tensor<?x?xi64> to tensor<10x15000xi64>
    %4 = tensor.empty() : tensor<15000x8xi64>
    %cast_3 = tensor.cast %4 : tensor<15000x8xi64> to tensor<?x?xi64>
    %5 = call @fillRandomI64Tensor2D(%cast_3) : (tensor<?x?xi64>) -> tensor<?x?xi64>
    %cast_4 = tensor.cast %5 : tensor<?x?xi64> to tensor<15000x8xi64>
    %6 = call @xy_z(%cast_0, %cast_2, %cast_4) : (tensor<10000x10xi64>, tensor<10x15000xi64>, tensor<15000x8xi64>) -> tensor<10000x8xi64>
    %cst = arith.constant 0.000000e+00 : f32
    return %cst : f32
  }
}


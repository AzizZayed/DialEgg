(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_divf (Op Op AttrPair Type) Op)

;;;; math dialect ;;;;
(function math_sqrt (Op AttrPair Type) Op)

;;;; func dialect ;;;;
; (function func_call_0 (AttrPair Type) Op)
(function func_call (Op AttrPair Type) Op)
; (function func_call_2 (Op Op AttrPair Type) Op)

;; OPS HERE ;;
(let op0 (Value 0 (RankedTensor (vec-of 1000000 3) (F64)))) ; %0 = tensor.empty() : tensor<1000000x3xf64>
(let op1 (Value 1 (RankedTensor (vec-of 1000000 3) (F32)))) ; %1 = arith.truncf %0 : tensor<1000000x3xf64> to tensor<1000000x3xf32>
(let op2 (Value 2 (I64))) ; %2 = func.call @clock() : () -> i64
(let op3 (func_call op1 (NamedAttr "callee" (SymbolRefAttr "normalize_distance_vectors")) (RankedTensor (vec-of 1000000 3) (F32)))) ; %3 = func.call @normalize_distance_vectors(%1) : (tensor<1000000x3xf32>) -> tensor<1000000x3xf32>
(let op4 (Value 4 (I64))) ; %4 = func.call @clock() : () -> i64
(let op5 (func_call op3 (NamedAttr "callee" (SymbolRefAttr "blackhole")) (RankedTensor (vec-of 1000000 3) (F32)))) ; %5 = func.call @blackhole(%3) : (tensor<1000000x3xf32>) -> tensor<1000000x3xf32>
(let op6 (Value 6 (None))) ; func.call @displayTime(%2, %4) : (i64, i64) -> ()
(let op7 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))) ; %c0_i32 = arith.constant 0 : i32
(let op8 (Value 8 (None))) ; func.return %c0_i32 : i32

;; RULES HERE ;;
(rewrite
    (arith_divf 
        (arith_constant (NamedAttr "value" (FloatAttr 1.0 (F32))) (F32)) ; 1.0
        (math_sqrt ?x (NamedAttr "fastmath" (arith_fastmath (fast))) (F32)) ; sqrt(x) with fastmath<fast>
        (NamedAttr "fastmath" (arith_fastmath (fast))) (F32)) ; 1 / sqrt(x) with fastmath<fast>
    (func_call ?x (NamedAttr "callee" (SymbolRefAttr "fast_inv_sqrt")) (F32))
)
(run 10000)

;; EXTRACTS HERE ;;
(extract op3)
(extract op5)
(extract op7)

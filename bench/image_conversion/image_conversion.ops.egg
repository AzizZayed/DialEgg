(include "src/base.egg")

;;;; arith dialect ;;;;
(function arith_constant (AttrPair Type) Op)
(function arith_divsi (Op Op Type) Op :cost 2)
(function arith_shrsi (Op Op Type) Op)

;; OPS HERE ;;
; rgb_to_grayscale_func.func
(let op0 (Value 0 (I64)))
(let op1 (Value 1 (I64)))
(let op2 (Value 2 (I64)))
(let op3 (arith_constant (NamedAttr "value" (IntegerAttr 256 (I64))) (I64)))
(let op4 (arith_constant (NamedAttr "value" (IntegerAttr 77 (I64))) (I64)))
(let op5 (arith_constant (NamedAttr "value" (IntegerAttr 150 (I64))) (I64)))
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 29 (I64))) (I64)))
(let op7 (Value 7 (I64)))
(let op8 (Value 8 (I64)))
(let op9 (Value 9 (I64)))
(let op10 (arith_divsi op7 op3 (I64)))
(let op11 (arith_divsi op8 op3 (I64)))
(let op12 (arith_divsi op9 op3 (I64)))
(let op13 (Value 13 (I64)))
(let op14 (Value 14 (I64)))
(let op15 (Value 15 (None)))

;; RULES HERE ;;
(ruleset rules)
(rule ; division by a power of 2 is equivalent to right shift
    ((= ?lhs (arith_divsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?n ?t)) ?t) ?t)) ; x / n
     (= ?lgn (log2 ?n)) ; if n = 2^k, then k = log2(n)
     (= ?n (<< 1 ?lgn))) ; check if n is a power of 2
    ((union ?lhs (arith_shrsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?lgn ?t)) ?t) ?t))) ; x / n = x >> lgn
    :ruleset rules
)

(run-schedule (saturate rules))

;; EXTRACTS HERE ;;
(extract op4)
(extract op5)
(extract op6)
(extract op10)
(extract op11)
(extract op12)

(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_muli (Op Op AttrPair Type) Op)
(function arith_divsi (Op Op Type) Op :cost 2)
(function arith_shrsi (Op Op Type) Op)
(function arith_shli (Op Op AttrPair Type) Op)

;; OPS HERE ;;
(let op0 (arith_constant (NamedAttr "value" (IntegerAttr 100 (I64))) (I64)))
(let op1 (Value 1 (RankedTensor (vec-of 3840 2160 3) (I64))))
(let op2 (Value 2 (RankedTensor (vec-of 3840 2160 3) (I64))))
(let op3 (Value 3 (RankedTensor (vec-of 3840 2160 3) (I64))))
(let op4 (Value 4 (I64)))
(let op5 (arith_constant (NamedAttr "value" (IntegerAttr 0 (Index))) (Index)))
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 1 (Index))) (Index)))
(let op7 (arith_constant (NamedAttr "value" (IntegerAttr 2 (Index))) (Index)))
(let op8 (arith_constant (NamedAttr "value" (IntegerAttr 3840 (Index))) (Index)))
(let op9 (arith_constant (NamedAttr "value" (IntegerAttr 2160 (Index))) (Index)))
(let op10 (Value 10 (RankedTensor (vec-of 3840 2160) (I64))))
(let op11 (Value 11 (RankedTensor (vec-of 3840 2160) (I64))))
(let op12 (Value 12 (I64)))
(let op13 (Value 13 (None)))
(let op14 (Value 14 (RankedTensor (vec-of 3840 2160) (I64))))
(let op15 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I64))) (I64)))
(let op16 (Value 16 (None)))

;; RULES HERE ;;
(ruleset rules)
(rule ; division by a power of 2 is equivalent to right shift
    ((= ?lhs (arith_divsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?n ?t)) ?t) ?t)) ; x / n
     (= ?lgn (log2 ?n)) ; if n = 2^k, then k = log2(n)
     (= ?n (<< 1 ?lgn))) ; check if n is a power of 2
    ((union ?lhs (arith_shrsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?lgn ?t)) ?t) ?t))) ; x / n = x >> lgn
    :ruleset rules
)

(run-schedule (saturate rules))
; (run 1000)
;; EXTRACTS HERE ;;

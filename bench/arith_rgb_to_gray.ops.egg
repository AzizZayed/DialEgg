(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_muli (Op Op AttrPair Type) Op)
(function arith_divsi (Op Op Type) Op :cost 2)
(function arith_shrsi (Op Op Type) Op)
(function arith_shli (Op Op AttrPair Type) Op)

;; OPS HERE ;;
(let op0 (arith_constant (NamedAttr "value" (IntegerAttr 100 (I64))) (I64))) ; %c100_i64 = arith.constant 100 : i64
(let op1 (Value 1 (RankedTensor (vec-of 3840 2160 3) (I64)))) ; %0 = tensor.empty() : tensor<3840x2160x3xi64>
(let op2 (Value 2 (RankedTensor (vec-of 3840 2160 3) (I64)))) ; %1 = linalg.fill ins(%c100_i64 : i64) outs(%0 : tensor<3840x2160x3xi64>) -> tensor<3840x2160x3xi64>
(let op3 (Value 3 (RankedTensor (vec-of 3840 2160 3) (I64)))) ; %2 = func.call @blackhole1(%1) : (tensor<3840x2160x3xi64>) -> tensor<3840x2160x3xi64>
(let op4 (Value 4 (I64))) ; %3 = func.call @clock() : () -> i64
(let op5 (arith_constant (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))) ; %c0 = arith.constant 0 : index
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))) ; %c1 = arith.constant 1 : index
(let op7 (arith_constant (NamedAttr "value" (IntegerAttr 2 (Index))) (Index))) ; %c2 = arith.constant 2 : index
(let op8 (arith_constant (NamedAttr "value" (IntegerAttr 3840 (Index))) (Index))) ; %c3840 = arith.constant 3840 : index
(let op9 (arith_constant (NamedAttr "value" (IntegerAttr 2160 (Index))) (Index))) ; %c2160 = arith.constant 2160 : index
(let op10 (Value 10 (RankedTensor (vec-of 3840 2160) (I64)))) ; %4 = tensor.empty() : tensor<3840x2160xi64>
(let op11 (Value 11 (RankedTensor (vec-of 3840 2160) (I64)))) ; %5 = scf.for %arg0 = %c0 to %c3840 step %c1 iter_args(%arg1 = %4) -> (tensor<3840x2160xi64>) {
;   %8 = scf.for %arg2 = %c0 to %c2160 step %c1 iter_args(%arg3 = %arg1) -> (tensor<3840x2160xi64>) {
;     %extracted = tensor.extract %2[%arg0, %arg2, %c0] : tensor<3840x2160x3xi64>
;     %extracted_0 = tensor.extract %2[%arg0, %arg2, %c1] : tensor<3840x2160x3xi64>
;     %extracted_1 = tensor.extract %2[%arg0, %arg2, %c2] : tensor<3840x2160x3xi64>
;     %9 = func.call @rgb_to_grayscale(%extracted, %extracted_0, %extracted_1) : (i64, i64, i64) -> i64
;     %inserted = tensor.insert %9 into %arg3[%arg0, %arg2] : tensor<3840x2160xi64>
;     scf.yield %inserted : tensor<3840x2160xi64>
;   }
;   scf.yield %8 : tensor<3840x2160xi64>
; }
(let op12 (Value 12 (I64))) ; %6 = func.call @clock() : () -> i64
(let op13 (Value 13 (RankedTensor (vec-of 3840 2160) (I64)))) ; %7 = func.call @blackhole2(%5) : (tensor<3840x2160xi64>) -> tensor<3840x2160xi64>
(let op14 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I64))) (I64))) ; %c0_i64 = arith.constant 0 : i64

;; RULES HERE ;;
(rule ; division by a power of 2 is equivalent to right shift
    ((= ?lhs (arith_divsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?n ?t)) ?t) ?t)) ; x / n
     (= ?lgn (log2 ?n)) ; if n = 2^k, then k = log2(n)
     (= ?n (<< 1 ?lgn))) ; check if n is a power of 2
    ((union ?lhs (arith_shrsi ?x (arith_constant (NamedAttr "value" (IntegerAttr ?lgn ?t)) ?t) ?t))) ; x / n = x >> lgn
)

(run 10000)

;; EXTRACTS HERE ;;
(extract op0)
(extract op5)
(extract op6)
(extract op7)
(extract op8)
(extract op9)
(extract op14)

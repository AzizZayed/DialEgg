(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_mulf (Op Op AttrPair Type) Op)
(function arith_addf (Op Op AttrPair Type) Op)

;;;; math dialect ;;;;
(function math_powf (Op Op AttrPair Type) Op :cost 10000)
;; OPS HERE ;;
(let op0 (Value 0 (I64))) ; <block argument> of type 'i64' at index: 0
(let op1 (Value 1 (I64))) ; <block argument> of type 'i64' at index: 1
(let op2 (Value 2 (I64))) ; %0 = arith.subi %arg1, %arg0 : i64
(let op3 (Value 3 (F64))) ; %1 = arith.uitofp %0 : i64 to f64
(let op4 (arith_constant (NamedAttr "value" (FloatAttr 100000000.0 (F64))) (F64))) ; %cst = arith.constant 1.000000e+08 : f64
(let op5 (Value 5 (F64))) ; %2 = arith.divf %1, %cst : f64
(let op6 (Value 6 (OtherType "!llvm.ptr" "llvm.ptr"))) ; %3 = llvm.mlir.addressof @time : !llvm.ptr
(let op7 (Value 7 (I32))) ; %4 = llvm.call @printf(%3, %0, %2) vararg(!llvm.func<i32 (ptr, ...)>) : (!llvm.ptr, i64, f64) -> i32

;; RULES HERE ;;
(rewrite (arith_addf ?x ?y ?a ?t) (arith_addf ?y ?x ?a ?t)) ; x + y = y + x
(rewrite (arith_mulf ?x ?y ?a ?t) (arith_mulf ?y ?x ?a ?t)) ; x * y = y * x
(rewrite ; x * 1 = x
    (arith_mulf ?x (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t) ?a ?t)
    ?x 
)

(rewrite ; x^0 = 1
    (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr 0.0 ?t)) ?t) ?a ?t) 
    (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t)
)
(rewrite ; x^1 = x
    (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t) ?a ?t)
    ?x
)
(rule ; x^n = x * x^(n-1)
    ((= ?lhs (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?n ?t)) ?t) ?a ?t))
     (> ?n 1.0))
    ((union 
        ?lhs 
        (arith_mulf ?x (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr (- ?n 1.0) ?t)) ?t) ?a ?t) ?a ?t)
    ))
)

(rule ; ax^n + bx^m = x^(min(n, m)) * (a * x^(n - min(n, m)) + b * x^(m - min(n, m))
    ((= ?lhs 
        (arith_addf
            (arith_mulf
                ?a
                (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?n ?t)) ?t) ?a ?t)
                ?a ?t
            )
            (arith_mulf
                ?b
                (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?m ?t)) ?t) ?a ?t)
                ?a ?t
            )
            ?a ?t
        )
    )
    (= ?min (min ?n ?m)))
    ((union
        ?lhs
        (arith_mulf
            (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?min ?t)) ?t) ?a ?t) ; x^(min(n, m))
            (arith_addf ; a * x^(n - min(n, m)) + b * x^(m - min(n, m))
                (arith_mulf ?a (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr (- ?n ?min) ?t)) ?t) ?a ?t) ?a ?t)
                (arith_mulf ?b (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr (- ?m ?min) ?t)) ?t) ?a ?t) ?a ?t)
                ?a ?t
            )
            ?a ?t
        )
    ))
)

(run 10000)

;; EXTRACTS HERE ;;
(extract op4)

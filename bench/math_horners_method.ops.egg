(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_mulf (Op Op AttrPair Type) Op :cost 100)
(function arith_addf (Op Op AttrPair Type) Op)

;;;; math dialect ;;;;
(function math_powf (Op Op AttrPair Type) Op :cost 100000)
;; OPS HERE ;;
(let op0 (Value 0 (RankedTensor (vec-of 1000000 4) (F64)))) ; %0 = tensor.empty() : tensor<1000000x4xf64>
(let op1 (Value 1 (RankedTensor (vec-of 1000000 4) (F64)))) ; %1 = func.call @fillRandomF64Tensor2D(%0) : (tensor<1000000x4xf64>) -> tensor<1000000x4xf64>
(let op2 (Value 2 (I64))) ; %2 = func.call @clock() : () -> i64
(let op3 (arith_constant (NamedAttr "value" (FloatAttr 1.0 (F64))) (F64))) ; %cst = arith.constant 1.000000e+00 : f64
(let op4 (arith_constant (NamedAttr "value" (IntegerAttr 0 (Index))) (Index))) ; %c0 = arith.constant 0 : index
(let op5 (arith_constant (NamedAttr "value" (IntegerAttr 1 (Index))) (Index))) ; %c1 = arith.constant 1 : index
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 2 (Index))) (Index))) ; %c2 = arith.constant 2 : index
(let op7 (arith_constant (NamedAttr "value" (IntegerAttr 3 (Index))) (Index))) ; %c3 = arith.constant 3 : index
(let op8 (arith_constant (NamedAttr "value" (IntegerAttr 1000000 (Index))) (Index))) ; %c1000000 = arith.constant 1000000 : index
(let op9 (Value 9 (RankedTensor (vec-of 1000000) (F64)))) ; %3 = tensor.empty() : tensor<1000000xf64>
(let op10 (Value 10 (RankedTensor (vec-of 1000000) (F64)))) ; %4 = scf.for %arg0 = %c0 to %c1000000 step %c1 iter_args(%arg1 = %3) -> (tensor<1000000xf64>) {
;   %extracted = tensor.extract %1[%arg0, %c0] : tensor<1000000x4xf64>
;   %extracted_0 = tensor.extract %1[%arg0, %c1] : tensor<1000000x4xf64>
;   %extracted_1 = tensor.extract %1[%arg0, %c2] : tensor<1000000x4xf64>
;   %extracted_2 = tensor.extract %1[%arg0, %c3] : tensor<1000000x4xf64>
;   %7 = func.call @poly_eval_3(%extracted, %extracted_0, %extracted_1, %extracted_2, %cst) : (f64, f64, f64, f64, f64) -> f64
;   %inserted = tensor.insert %7 into %arg1[%arg0] : tensor<1000000xf64>
;   scf.yield %inserted : tensor<1000000xf64>
; }
(let op11 (Value 11 (I64))) ; %5 = func.call @clock() : () -> i64
(let op12 (Value 12 (RankedTensor (vec-of -9223372036854775808) (F64)))) ; %cast = tensor.cast %4 : tensor<1000000xf64> to tensor<?xf64>
(let op13 (Value 13 (RankedTensor (vec-of -9223372036854775808) (F64)))) ; %6 = func.call @blackhole(%cast) : (tensor<?xf64>) -> tensor<?xf64>
(let op14 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))) ; %c0_i32 = arith.constant 0 : i32

;; RULES HERE ;;

; commutative
(rewrite (arith_addf ?x ?y ?a ?t) (arith_addf ?y ?x ?a ?t)) ; x + y = y + x
(rewrite (arith_mulf ?x ?y ?a ?t) (arith_mulf ?y ?x ?a ?t)) ; x * y = y * x

; associative
(rewrite (arith_addf (arith_addf ?x ?y ?a ?t) ?z ?a ?t) (arith_addf ?x (arith_addf ?y ?z ?a ?t) ?a ?t)) ; (x + y) + z = x + (y + z)
(rewrite (arith_mulf (arith_mulf ?x ?y ?a ?t) ?z ?a ?t) (arith_mulf ?x (arith_mulf ?y ?z ?a ?t) ?a ?t)) ; (x * y) * z = x * (y * z)

; identity
(rewrite (arith_mulf ?x (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t) ?a ?t) ?x) ; x * 1 = x
(rewrite ; x^0 = 1
    (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr 0.0 ?t)) ?t) ?a ?t) 
    (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t)
)

(rule ; x^n = x * x^(n - 1)
    ((= ?lhs (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?n ?t)) ?t) ?a ?t))
     (>= ?n 1.0))
    ((union 
        ?lhs 
        (arith_mulf ?x (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr (- ?n 1.0) ?t)) ?t) ?a ?t) ?a ?t)
    ))
)

; mx + nx = x(m + n)
(rewrite 
    (arith_addf (arith_mulf ?m ?x ?a ?t) (arith_mulf ?n ?x ?a ?t) ?a ?t)
    (arith_mulf ?x (arith_addf ?m ?n ?a ?t) ?a ?t)
)

(run 10000)

;; EXTRACTS HERE ;;
(extract op3)
(extract op4)
(extract op5)
(extract op6)
(extract op7)
(extract op8)
(extract op14)

(include "src/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_mulf (Op Op AttrPair Type) Op :cost 100)
(function arith_addf (Op Op AttrPair Type) Op)

;;;; math dialect ;;;;
(function math_powf (Op Op AttrPair Type) Op :cost 100000)

;; OPS HERE ;;
(let op0 (Value 0 (F64)))
(let op1 (Value 1 (F64)))
(let op2 (Value 2 (F64)))
(let op3 (Value 3 (F64)))
(let op4 (Value 4 (F64)))
(let op5 (Value 5 (F64)))
(let op6 (arith_constant (NamedAttr "value" (FloatAttr 2.0 (F64))) (F64)))
(let op7 (arith_constant (NamedAttr "value" (FloatAttr 3.0 (F64))) (F64)))
(let op8 (arith_constant (NamedAttr "value" (FloatAttr 4.0 (F64))) (F64)))
(let op9 (math_powf op5 op6 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op10 (math_powf op5 op7 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op11 (math_powf op5 op8 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op12 (arith_mulf op3 op5 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op13 (arith_mulf op2 op9 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op14 (arith_mulf op1 op10 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op15 (arith_mulf op0 op11 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op16 (arith_addf op14 op15 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op17 (arith_addf op13 op16 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op18 (arith_addf op12 op17 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op19 (arith_addf op4 op18 (NamedAttr "fastmath" (arith_fastmath (none))) (F64)))
(let op20 (Value 20 (None)))

;; RULES HERE ;;
(ruleset rules)

; commutative
(rewrite (arith_addf ?x ?y ?a ?t) (arith_addf ?y ?x ?a ?t) :ruleset rules) ; x + y = y + x
(rewrite (arith_mulf ?x ?y ?a ?t) (arith_mulf ?y ?x ?a ?t) :ruleset rules) ; x * y = y * x

; associative
(rewrite ; (x + y) + z = x + (y + z)
    (arith_addf (arith_addf ?x ?y ?a ?t) ?z ?a ?t) 
    (arith_addf ?x (arith_addf ?y ?z ?a ?t) ?a ?t) 
    :ruleset rules
)
(rewrite ; (x * y) * z = x * (y * z)
    (arith_mulf (arith_mulf ?x ?y ?a ?t) ?z ?a ?t) 
    (arith_mulf ?x (arith_mulf ?y ?z ?a ?t) ?a ?t) 
    :ruleset rules
)

; identity
(rewrite (arith_mulf ?x (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t) ?a ?t) ?x :ruleset rules) ; x * 1 = x
(rewrite ; x^0 = 1
    (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr 0.0 ?t)) ?t) ?a ?t) 
    (arith_constant (NamedAttr "value" (FloatAttr 1.0 ?t)) ?t)
    :ruleset rules
)

(rule ; x^n = x * x^(n - 1)
    ((= ?lhs (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr ?n ?t)) ?t) ?a ?t))
     (>= ?n 1.0))
    ((union 
        ?lhs 
        (arith_mulf ?x (math_powf ?x (arith_constant (NamedAttr "value" (FloatAttr (- ?n 1.0) ?t)) ?t) ?a ?t) ?a ?t)
    ))
    :ruleset rules
)

; mx + nx = x(m + n)
(rewrite 
    (arith_addf (arith_mulf ?m ?x ?a ?t) (arith_mulf ?n ?x ?a ?t) ?a ?t)
    (arith_mulf ?x (arith_addf ?m ?n ?a ?t) ?a ?t)
    :ruleset rules
)

(run-schedule (saturate rules)) ; search 0.017s, apply 0.002s, rebuild 0.006s, total 0.025s

;; EXTRACTS HERE ;;
(extract op19)

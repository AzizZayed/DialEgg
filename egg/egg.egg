(include "egg/base.egg")

;;;; arith dialect ;;;;

;; Attrs
(datatype FastMathFlags (none) (reassoc) (nnan) (fast))
(function arith_fastmath (FastMathFlags) Attr)

;; Ops
(function arith_constant (AttrPair Type) Op)
(function arith_addf (Op Op AttrPair Type) Op)
(function arith_subf (Op Op AttrPair Type) Op)
(function arith_mulf (Op Op AttrPair Type) Op)
(function arith_muli (Op Op AttrPair Type) Op)
(function arith_divf (Op Op AttrPair Type) Op)
(function arith_divsi (Op Op Type) Op :cost 2)
(function arith_shrsi (Op Op Type) Op)
(function arith_shli (Op Op AttrPair Type) Op)

;;;; math dialect ;;;;
(function math_sin (Op AttrPair Type) Op)
(function math_cos (Op AttrPair Type) Op)
(function math_powf (Op Op AttrPair Type) Op)

;;;; linalg dialect ;;;;
(function linalg_transpose (Op Op AttrPair Type) Op)
(function linalg_matmul (Op Op Op Type) Op)

;;;; tensor dialect ;;;;
(function tensor_empty (Type) Op)

;;;; func dialect ;;;;
(function func_call (AttrPair Type) Op)

;; OPS HERE ;;
(let op0 (arith_constant (NamedAttr "value" (FloatAttr 24025.0 (F32))) (F32))) ; %cst = arith.constant 2.402500e+04 : f32
(let op1 (func_call (NamedAttr "callee" (SymbolRefAttr "clock")) (I64))) ; %0 = func.call @clock() : () -> i64
(let op2 (arith_constant (NamedAttr "value" (FloatAttr 1.0 (F32))) (F32))) ; %cst_0 = arith.constant 1.000000e+00 : f32
(let op3 (Value 3 (F32))) ; %1 = math.sqrt %cst fastmath<fast> : f32
(let op4 (arith_divf op2 op3 (NamedAttr "fastmath" (arith_fastmath (fast))) (F32))) ; %2 = arith.divf %cst_0, %1 fastmath<fast> : f32
(let op5 (func_call (NamedAttr "callee" (SymbolRefAttr "clock")) (I64))) ; %3 = func.call @clock() : () -> i64
(let op6 (arith_constant (NamedAttr "value" (IntegerAttr 0 (I32))) (I32))) ; %c0_i32 = arith.constant 0 : i32

;; RULES HERE ;;
(run 10000)

;; EXTRACTS HERE ;;
(extract op0)
(extract op1)
(extract op2)
(extract op4)
(extract op5)
(extract op6)

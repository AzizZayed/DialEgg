(sort Math)

(function Var (String) Math)
(function Num (i64) Math)
(function Add (Math Math) Math)
(function Mul (Math Math) Math :cost 100)
(function Pow (Math i64 ) Math :cost 100000)

(let vx (Var "x"))
(let va (Var "a"))
(let vb (Var "b"))
(let vc (Var "c"))
(let vd (Var "d"))
(let ve (Var "e"))
(let vf (Var "f"))

(let poly2 (Add (Mul va (Pow vx 2)) (Add (Mul vb vx) vc))) ; ax^2 + bx + c
(let poly3 (Add (Mul va (Pow vx 3)) (Add (Mul vb (Pow vx 2)) (Add (Mul vc vx) vd)))) ; d + cx + bx^2 + ax^3
(let poly4 (Add (Mul va (Pow vx 4)) (Add (Mul vb (Pow vx 3)) (Add (Mul vc (Pow vx 2)) (Add (Mul vd vx) ve))))) ; e + dx + cx^2 + bx^3 + ax^4
(let poly5 (Add (Mul va (Pow vx 5)) (Add (Mul vb (Pow vx 4)) (Add (Mul vc (Pow vx 3)) (Add (Mul vd (Pow vx 2)) (Add (Mul ve vx) vf)))))) ; f + ex + dx^2 + cx^3 + bx^4 + ax^5

; commute
(rewrite (Add ?x ?y) (Add ?y ?x)) ; x + y = y + x
(rewrite (Mul ?x ?y) (Mul ?y ?x)) ; x * y = y * x

; associative
(rewrite (Add ?x (Add ?y ?z)) (Add (Add ?x ?y) ?z)) ; (x + y) + z = x + (y + z)
(rewrite (Mul ?x (Mul ?y ?z)) (Mul (Mul ?x ?y) ?z)) ; (x * y) * z = x * (y * z)

; identity
(rewrite (Mul ?x (Num 1)) ?x) ; x * 1 = x
(rewrite (Pow ?x 0) (Num 1)) ; x^0 = 1

(rule ((= ?lhs (Pow ?x ?n)) (>= ?n 1)) ((union ?lhs (Mul ?x (Pow ?x (- ?n 1)))))) ; x^n = x * x^(n-1)
(rewrite (Add (Mul ?a ?x) (Mul ?b ?x)) (Mul ?x (Add ?a ?b))) ; ax + bx = x(a+b)

(run 100)

(extract poly3)